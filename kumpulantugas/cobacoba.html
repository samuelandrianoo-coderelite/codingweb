<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Super AI — Single File HTML Game</title>
  <style>
    :root{--bg:#0b1020;--panel:#0f1724;--accent:#7dd3fc;--danger:#fb7185;--muted:#94a3b8}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{background:linear-gradient(180deg,#071024 0%, #07182a 50%, #0b1020 100%);display:flex;align-items:center;justify-content:center;color:#e6eef8}
    .container{width:960px;max-width:95vw;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,0.6);overflow:hidden}
    header{display:flex;align-items:center;justify-content:space-between;padding:14px 18px;background:rgba(255,255,255,0.02)}
    h1{font-size:18px;margin:0;letter-spacing:0.6px}
    .controls{display:flex;gap:10px;align-items:center}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:var(--accent);cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .main{display:flex;gap:16px;padding:16px}
    canvas{background:linear-gradient(180deg,#081226 0%, #071028 100%);border-radius:8px;border:1px solid rgba(255,255,255,0.03);box-shadow:inset 0 2px 10px rgba(0,0,0,0.6)}
    .sidebar{width:320px;max-width:32vw;padding:8px 10px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:8px}
    .panel{background:var(--panel);padding:12px;border-radius:10px;margin-bottom:12px}
    .muted{color:var(--muted);font-size:13px}
    .stat{display:flex;justify-content:space-between;align-items:center;margin:6px 0}
    .meter{height:10px;background:rgba(255,255,255,0.03);border-radius:6px;overflow:hidden}
    .meter > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#60a5fa);width:50%}
    footer{padding:10px;text-align:center;color:var(--muted);font-size:13px}
    .kbd{background:#0b1220;padding:4px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.02);font-family:monospace}
    .legend{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
    .legend .key{display:flex;gap:8px;align-items:center;font-size:13px}
    .swatch{width:14px;height:14px;border-radius:4px}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Super AI — Escape & Outsmart</h1>
      <div class="controls">
        <button id="startBtn" class="btn">Start</button>
        <button id="pauseBtn" class="btn">Pause</button>
        <button id="resetBtn" class="btn">Reset</button>
      </div>
    </header>

    <div class="main">
      <canvas id="game" width="640" height="480"></canvas>
      <aside class="sidebar">
        <div class="panel">
          <div class="muted">Score</div>
          <div style="font-size:28px;font-weight:700;"> <span id="score">0</span></div>
          <div class="stat"><div class="muted">High score</div><div id="high">0</div></div>
        </div>

        <div class="panel">
          <div class="muted">Player</div>
          <div class="stat"><div>Health</div><div id="hp">100</div></div>
          <div class="meter" style="margin-top:6px"><i id="hpbar" style="width:100%"></i></div>
          <div class="stat"><div>Level</div><div id="level">1</div></div>
        </div>

        <div class="panel">
          <div class="muted">AI Opponents</div>
          <div class="stat"><div>Count</div><div id="bots">0</div></div>
          <div class="muted" style="margin-top:8px">AI Mode: <strong id="aimode">Predictive</strong></div>
          <div class="legend">
            <div class="key"><div class="swatch" style="background:#7dd3fc"></div> Player</div>
            <div class="key"><div class="swatch" style="background:#fb7185"></div> Threat</div>
            <div class="key"><div class="swatch" style="background:#fbbf24"></div> Power-up</div>
          </div>
        </div>

        <div class="panel">
          <div class="muted">Controls</div>
          <div style="margin-top:8px">Move: <span class="kbd">W A S D</span> or <span class="kbd">Arrow keys</span></div>
          <div style="margin-top:6px">Dash (short burst): <span class="kbd">Space</span></div>
        </div>

      </aside>
    </div>

    <footer>
      Tip: AI learns simple patterns — vary your movement. Saved locally in your browser.
    </footer>
  </div>

  <script>
  // Super AI — single-file JS game
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    // UI
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high');
    const botsEl = document.getElementById('bots');
    const hpEl = document.getElementById('hp');
    const hpbar = document.getElementById('hpbar');
    const levelEl = document.getElementById('level');
    const aimodeEl = document.getElementById('aimode');

    // Game state
    let running=false, paused=false, frame=0;
    let score=0, high=Number(localStorage.getItem('superAI_high')||0);
    highEl.textContent = high;
    let level = 1;

    // Player
    const player = {x: W/2, y: H/2, r:10, speed:2.2, vx:0, vy:0, hp:100, dashCooldown:0};

    // Key input
    const keys = {};
    window.addEventListener('keydown', e=>{keys[e.key.toLowerCase()]=true; if([' ','spacebar'].includes(e.key.toLowerCase())) e.preventDefault();});
    window.addEventListener('keyup', e=>{keys[e.key.toLowerCase()]=false});

    // Powerups, bots
    let bots = [];
    let powerups = [];

    // Simple AI memory model — Markov-ish for direction sequences
    // Tracks recent player moves as 'U','D','L','R','S' and learns next-step frequencies
    const AIMemory = {
      order:2,
      counts: {}, // {"UD": {"L":3, "U":1}}
      recent: [],
      add(seq, next){ this.counts[seq]=this.counts[seq]||{}; this.counts[seq][next]=(this.counts[seq][next]||0)+1; },
      push(dir){ this.recent.push(dir); if(this.recent.length>this.order) this.recent.shift(); },
      predict(){ const key=this.recent.join(''); const entry=this.counts[key]; if(!entry) return null; // return direction with max count
        let best=null, mx=0; for(const d in entry){ if(entry[d]>mx){ mx=entry[d]; best=d; }} return best;
      }
    };

    // Helper utilities
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
    function spawnBot(){
      const angle = Math.random()*Math.PI*2;
      const radius = Math.max(W,H)/2 + 30 + Math.random()*80;
      const bx = W/2 + Math.cos(angle)*radius;
      const by = H/2 + Math.sin(angle)*radius;
      const bot = {x:bx,y:by,r:12, speed:1.1 + Math.random()*0.7, type:'hunter', color:'#fb7185', charge:0};
      bots.push(bot);
    }

    function spawnPowerup(){
      powerups.push({x:40 + Math.random()*(W-80), y:40 + Math.random()*(H-80), r:8, t: Math.random()>0.6? 'heal':'score'});
    }

    function resetGame(){
      score=0; level=1; player.x=W/2; player.y=H/2; player.hp=100; bots=[]; powerups=[]; AIMemory.counts={}; AIMemory.recent=[]; frame=0; updateUI();
      // initial bots
      for(let i=0;i<3;i++) spawnBot();
      for(let i=0;i<2;i++) spawnPowerup();
    }

    function updateUI(){ scoreEl.textContent = score; botsEl.textContent = bots.length; hpEl.textContent = Math.max(0,Math.floor(player.hp)); hpbar.style.width = Math.max(0,player.hp) + '%'; levelEl.textContent = level; aimodeEl.textContent = 'Predictive'; }

    function stepPlayer(dt){
      let ax=0, ay=0; const s=player.speed;
      if(keys['w']||keys['arrowup']) ay-=1;
      if(keys['s']||keys['arrowdown']) ay+=1;
      if(keys['a']||keys['arrowleft']) ax-=1;
      if(keys['d']||keys['arrowright']) ax+=1;

      // normalize
      if(ax!==0||ay!==0){ const L=Math.hypot(ax,ay); ax/=L; ay/=L; player.vx = ax*s; player.vy = ay*s; }
      else { player.vx = 0; player.vy = 0; }

      // dash
      if((keys[' ']||keys['space']) && player.dashCooldown<=0){ player.vx *= 4; player.vy *=4; player.dashCooldown = 60; }
      if(player.dashCooldown>0) player.dashCooldown -= 1;

      player.x += player.vx;
      player.y += player.vy;

      player.x = clamp(player.x, player.r, W-player.r);
      player.y = clamp(player.y, player.r, H-player.r);

      // update AI memory: convert movement vector to direction token
      let dir='S'; if(Math.abs(player.vx) > Math.abs(player.vy)) dir = player.vx>0? 'R':'L'; else if(Math.abs(player.vy)>0) dir = player.vy>0? 'D':'U';
      if(frame%6===0){ // sample less often
        const prev = AIMemory.recent.join('');
        if(AIMemory.recent.length===AIMemory.order){ // if we have a previous sequence, record transition
          AIMemory.add(prev, dir);
        }
        AIMemory.push(dir);
      }
    }

    function stepBots(dt){
      // Bots use predictive interception: they ask AIMemory for predicted direction and compute predicted future player position
      const predDir = AIMemory.predict();
      let predictOffset = {x:0,y:0};
      if(predDir){ const step = 40 + Math.min(100, score*0.15);
        if(predDir==='L') predictOffset.x = -step;
        if(predDir==='R') predictOffset.x = step;
        if(predDir==='U') predictOffset.y = -step;
        if(predDir==='D') predictOffset.y = step;
      }
      const target = {x: clamp(player.x + predictOffset.x, 0, W), y: clamp(player.y + predictOffset.y, 0, H)};

      bots.forEach(b=>{
        // steering toward the predicted target
        const dx = target.x - b.x; const dy = target.y - b.y;
        const L = Math.hypot(dx,dy)||1;
        const nx = dx/L, ny = dy/L;
        // acceleration and simple flocking separation
        let ax = nx * b.speed, ay = ny * b.speed;
        // separation from other bots
        bots.forEach(o=>{ if(o!==b){ const d = Math.hypot(b.x-o.x,b.y-o.y); if(d<30 && d>0){ ax += (b.x - o.x)/d * 0.6; ay += (b.y - o.y)/d * 0.6; }} });
        b.x += ax; b.y += ay;

        // collision with player
        const d = Math.hypot(b.x-player.x,b.y-player.y);
        if(d < b.r + player.r){ // hit
          player.hp -= 0.6; // damage over time
          // small knockback
          const k = 6; player.x -= (b.x-player.x)/d * k; player.y -= (b.y-player.y)/d * k;
        }
      });

      // remove offscreen unlikely
    }

    function stepPowerups(dt){
      // pickup
      for(let i=powerups.length-1;i>=0;i--){ const p=powerups[i]; if(Math.hypot(p.x-player.x,p.y-player.y) < p.r+player.r){ if(p.t==='heal'){ player.hp = clamp(player.hp + 25, 0, 100); } else { score += 10; } powerups.splice(i,1); }}
      // spawn occasionally
      if(frame%600===0 && Math.random()<0.9) spawnPowerup();
    }

    function aiDifficultyRamp(){
      // increase bots gradually based on score/time
      if(frame%900===0){ spawnBot(); }
      if(frame%1800===0){ level++; }
    }

    function gameLoop(){
      if(!running || paused) return;
      frame++;
      const dt = 1/60;
      // clear
      ctx.clearRect(0,0,W,H);

      // background subtle grid
      ctx.save();
      ctx.globalAlpha=0.06; ctx.strokeStyle='#2b3a4a'; ctx.lineWidth=1; for(let gx=0;gx<W;gx+=40){ ctx.beginPath(); ctx.moveTo(gx,0); ctx.lineTo(gx,H); ctx.stroke(); } for(let gy=0;gy<H;gy+=40){ ctx.beginPath(); ctx.moveTo(0,gy); ctx.lineTo(W,gy); ctx.stroke(); } ctx.restore();

      stepPlayer(dt);
      stepBots(dt);
      stepPowerups(dt);
      aiDifficultyRamp();

      // draw powerups
      powerups.forEach(p=>{
        ctx.beginPath(); ctx.fillStyle = '#fbbf24'; ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.fillStyle='#071226'; ctx.font='10px monospace'; ctx.fillText(p.t==='heal'?'+HP':'+S', p.x-6, p.y+3);
      });

      // draw player
      ctx.beginPath(); ctx.fillStyle = '#7dd3fc'; ctx.arc(player.x,player.y,player.r,0,Math.PI*2); ctx.fill();
      // player eye/heading
      ctx.beginPath(); ctx.fillStyle='#052022'; ctx.arc(player.x + Math.sign(player.vx||1)*4, player.y + Math.sign(player.vy||0)*3, 3,0,Math.PI*2); ctx.fill();

      // draw bots
      bots.forEach(b=>{
        ctx.beginPath(); ctx.fillStyle = b.color; ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
        // pulse
        ctx.beginPath(); ctx.strokeStyle='rgba(255,255,255,0.04)'; ctx.arc(b.x,b.y,b.r+6*Math.sin(frame/20), b.r,0,Math.PI*2); ctx.stroke();
      });

      // HUD
      ctx.fillStyle='#e6eef8'; ctx.font='12px Inter, system-ui'; ctx.fillText('Score: '+score,10,16); ctx.fillText('Level: '+level,10,34);

      // update score slowly
      if(frame%12===0){ score += 1; }

      // lose condition
      if(player.hp<=0){ endGame(); }

      // update high score
      if(score>high){ high = score; localStorage.setItem('superAI_high', high); highEl.textContent = high; }

      updateUI();

      requestAnimationFrame(gameLoop);
    }

    function endGame(){ running=false; paused=false; alert('Game Over! Score: '+score); }

    // UI hooks
    startBtn.addEventListener('click', ()=>{ if(!running){ running=true; resetGame(); requestAnimationFrame(gameLoop);} paused=false; });
    pauseBtn.addEventListener('click', ()=>{ paused = !paused; if(!paused && running) requestAnimationFrame(gameLoop); pauseBtn.textContent = paused? 'Resume': 'Pause'; });
    resetBtn.addEventListener('click', ()=>{ if(confirm('Reset game?')){ resetGame(); } });

    // small friendly autosave for memory model
    setInterval(()=>{ localStorage.setItem('superAI_memory', JSON.stringify(AIMemory.counts)); }, 5000);
    // restore memory if exists
    const savedMem = localStorage.getItem('superAI_memory'); if(savedMem) { try{ AIMemory.counts = JSON.parse(savedMem); }catch(e){ AIMemory.counts = {}; } }

    // start paused state ready
    resetGame(); running=false; paused=true; pauseBtn.textContent='Resume';

    // touch support
    canvas.addEventListener('touchstart', e=>{ const t = e.touches[0]; const rect = canvas.getBoundingClientRect(); const tx = t.clientX-rect.left; const ty = t.clientY-rect.top; // teleport player to touch
      player.x = clamp(tx, player.r, W-player.r); player.y = clamp(ty, player.r, H-player.r); e.preventDefault(); });

    // polishing: small FPS friendly loop even when paused
    (function idleLoop(){ if(running && !paused) requestAnimationFrame(idleLoop); else setTimeout(idleLoop, 500); })();

  })();
  </script>
</body>
</html>
